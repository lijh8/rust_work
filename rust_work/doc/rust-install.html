<html>

<head>
    <style>
        /* https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme */
        :root {
            color-scheme: light dark
        }
    </style>
</head>

<body>

    <textarea disabled style="
    border: none;
    font-family: monospace;
    font-size: inherit;
    height: 100%;
    overflow-wrap: break-word;
    resize: none;
    width: 100%;">


Rust install

Rust mirror:

$ vi ~/.profile
export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup
export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup
. "$HOME/.cargo/env"
$
$ source ~/.profile

# [ rsproxy
# export RUSTUP_DIST_SERVER="https://rsproxy.cn"
# export RUSTUP_UPDATE_ROOT="https://rsproxy.cn/rustup"
# ]


Cargo mirror:

$ rm ~/.cargo/.package-cache
$
$ vi ~/.cargo/config.toml
[source.crates-io]
replace-with = 'tuna'
[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"
$

---

$ vi ~/.profile
export RUSTUP_DIST_SERVER="https://rsproxy.cn"
export RUSTUP_UPDATE_ROOT="https://rsproxy.cn/rustup"
. "$HOME/.cargo/env"
$
$ source ~/.profile

$ rm ~/.cargo/.package-cache
$
$ vi ~/.cargo/config.toml
[source.crates-io]
replace-with = 'rsproxy-sparse'
[source.rsproxy]
registry = "https://rsproxy.cn/crates.io-index"
[source.rsproxy-sparse]
registry = "sparse+https://rsproxy.cn/index/"
[registries.rsproxy]
index = "https://rsproxy.cn/crates.io-index"
[net]
git-fetch-with-cli = true
$


---


$ apt install build-essential
$ apt install curl

$ source ~/.profile
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

$ source "$HOME/.cargo/env"
$ rustc --version

$ rustup update stable
$ cargo update  # in project directory with Cargo.toml

$ rustup doc --book
$ rustup self uninstall

## install dir:
/Users/ljh/.rustup ,
/Users/ljh/.cargo/bin ,

## profile:
/Users/ljh/.profile ,
/Users/ljh/.zshenv ,
/Users/ljh/.cargo/env ,

## with homebrew on macOS:
$ brew install rustup-init
$ rustup-init
$ brew update


---


https://doc.rust-lang.org/book/ ,
https://doc.rust-lang.org/std/ ,
https://crates.io ,
https://docs.rs ,


---


// https://github.com/rust-lang/rustfmt ,
// https://github.com/rust-lang/rustfmt/blob/master/Configurations.md ,

$ cd ~  # $HOME, or workspace package root dir
$ rustfmt  --print-config  default  rustfmt.toml
$ vi rustfmt.toml
disable_all_formatting = true
ignore = [
    "src",
    "/",
]
$


---


VSCode extensions:
matklad.rust-analyzer,
vadimcn.vscode-lldb,

VSCode settings:
    "rust-analyzer.hover.actions.enable": false,
    "rust-analyzer.inlayHints.typeHints.enable": true,
    "rust-analyzer.lens.enable": false,

// turn off underline for variable
// https://code.visualstudio.com/docs/languages/rust#_semantic-syntax-highlighting ,
    "editor.semanticHighlighting.enabled": false,


VSCode shortcuts:

Trigger suggestion       : Cmd I
Trigger suggestion       : Option Esc
Trigger parameter hints  : Shift Cmd Space
Format                   : Shift Option F
Show integrated terminal : Ctrl `


---


Coding style:

https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md ,
https://github.com/rust-dev-tools/fmt-rfcs ,
https://rustc-dev-guide.rust-lang.org/conventions.html ,


---


Create workspace and module:

$ cd ~
$ mkdir work
$ cd ~/work
$ vi Cargo.toml
[workspace]
resolver = "2"
members = [
    "main",
    "foo",
]
$ cargo new main
$ cargo new foo --lib

// https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#multiple-locations ,

# add dependencies by editing Cargo.toml
$ vi ~/work/main/Cargo.toml
[dependencies]
foo = { path = "../foo", version = "0.1.0" }
$

# or use cargo add command
$ cargo add log  # from crates.io
$ cat ~/work/main/Cargo.toml
[dependencies]
log = "0.4.22"
$


$ vi ~/work/main/src/main.rs
use rand::Rng;
use foo;

fn main() {
    println!("{}", foo::add(1, 2));
}
$

$ cat ~/work/foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2021"

[dependencies]

$
$ cat ~/work/foo/src/lib.rs
pub fn add(left: usize, right: usize) -> usize {
    left + right
}
$


// vscode generates correct launch.json with workspace Cargo.toml.
$ cat ~/work/.vscode/launch.json

{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'main'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=main",
                    "--package=main"
                ],
                "filter": {
                    "name": "main",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
    ]
}

$


---


$ rm ~/.cargo/.package-cache
$ cargo update
$ cargo new main
$ cargo new foo --lib
$ cargo build
$ cargo build --release
$ cargo run
$ cargo run --bin main # under directory with workspace Cargo.toml
$ cargo check
$ ./target/debug/main
$ cargo clean
$ cargo test


---


crate:
is like the target in Makefile, built from c++ source files;
it is also the source files which are used to build the target;
it can be library and executable;
src/lib.rs is library crate root file;
src/main.rs is binary crate root file;

package:
is like the build system and manages dependency with Cargo.toml;

module:
is a source file if do not define inline module;
declare module using ` mod foo; `, no braces.
define inline moudle using ` mod foo {} `, with braces.
non-main modules files should be declared in src/lib.rs library crate root file;
submodules files should be declared in file with same name as the sub-directory;
names only visible inside same module file by default;


---


Managing Growing Projects with Packages, Crates, and Modules ,

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html ,
https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html ,

The module tree might remind you of the filesystem’s directory tree on your computer;
this is a very apt comparison!
Just like directories in a filesystem, you use modules to organize your code.
And just like files in a directory, we need a way to find our modules.

- similar to python, in which a module is a source file;
- a module is a source file. a source file is a moudle;
- unless it is inline module;

module:

1. crate root file: src/main.rs, src/lib.rs,
-   mod foo;
-   foo::fun();
-   use foo::fun;
-   fun();
-   use foo::fun as fun2();
-   fun2();

- use public items in files in same directory: src/foo.rs, in the same crate;

2. non root file: src/foo.rs,
-   mod bar;
-   use bar::fun();
-   use crate::bar;

- use public items in sub-directories: src/foo/bar.rs, in the same crate;


crate:

- binary crates (src/main.rs);
- library crates (src/lib.rs), which can be used by other crates;
-   use foo; // use external crate `foo`, workspace/members, package/name;


package:

- a package is a crate with Cargo.toml;
- Cargo.toml describes package name, package version, rust version, dependencies;


---


$ pwd
/Users/ljh/Documents/rust_work/main/src
$
$ ls
bar.rs  foo     foo.rs  main.rs
$
$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'

.
|____foo.rs
|____foo
| |____bar.rs
|____main.rs
|____bar.rs
$

$ cat main.rs
mod bar; // pub required for access from outside the crate
mod foo;
use foo::bar as bar2; // sub-directory src/foo/bar.rs imported in foo.fs

fn main() {
    println!("main");
    foo::foo();
    bar::bar();
    bar2::bar();
}
$

$ cat foo.rs
pub mod bar; // for sub-directory src/foo/bar.rs
use crate::bar as bar1; // src/bar.rs imported in main.rs

pub fn foo() {
    println!("foo");
    bar::bar(); // src/foo/bar.rs
    bar1::bar(); // src/bar.rs
}
$

$ cat bar.rs
pub fn bar() {
    println!("bar1");
}
$

$ cat foo/bar.rs
pub fn bar() {
    println!("bar2");
}
$


---


1.

// src/lib.rs  // library crate root ,
mod foo; // there'll be: src/foo.rs, it needs no foo directory

// src/foo.rs ,
pub mod bar;  // there'll be: src/foo/bar.rs, it needs foo directory


---


Packages and Crates ,
https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html ,

A package can contain as many binary crates as you like,
but at most only one library crate.

A package must contain at least one crate,
whether thats a library or binary crate.


---


The Rust Programming Language, 7.1,
Rust By Example, 12.1, 12.2,


```
A crate can come in one of two forms: a binary crate or a library crate.
A package can contain as many binary crates as you like,
but at most only one library crate.
```

1. a package is crate with Cargo.toml,
a package manages dependencies for crate and
help build crate into library or binary.


2. a module is either inline module or a source file,
module tree is defined in src/lib.rs.
a source file with no main function is a module.


3.1. src/main.rs defines binary crate.

under `src/` directory, there can be only one source file with main function,
which is src/main.rs.
additional source files with main function should all be placed in `bin` sub-directory
`src/bin/main2.rs`,
`src/bin/main3.rs`.

a package has more than one binary crates means that when the package is built,
it generates more than one executable binary in ` ./target/ ` using ` cargo build ` .
this is the meaning of more than one binary crates.

and for a package can generates more than one binary crates,
it needs a sub-directory under src,
additional binaries are generated by files also contain main function in `bin` sub-directory,
eg. ` src/bin/main2.rs `, ` src/bin/main3.rs `.


3.2. src/lib.rs defines library crate.

a package has at most one library crate means that when the package is built,
it generates at most one library. there can be more files like
src/lib.rs, src/lib2.rs, src/lib2/lib3.rs,
they do not contain main function, and together they are built into one library
in ` ./target/ ` too using ` cargo build `.


---


```
foo/src/main.rs,
foo/src/bin/main2.rs,
foo/src/bin/main3.rs,
foo/src/lib.rs,
foo/src/lib2.rs,
foo/src/lib3.rs,
foo/src/lib4/lib5.rs,
foo/src/lib4/lib6.rs,
```


---


When a package contains only binary crate:

if additional binary crates are needed,
they all should be placed in `bin` sub-directory,
`src/bin/main2.rs`,
`src/bin/main3.rs`.

$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'

|____src
| |____bin
| | |____main2.rs
| |____main.rs


$ ls -l target/debug
-rwxr-xr-x    1 ljh  staff  471288 Oct  5 15:30 main
-rwxr-xr-x    1 ljh  staff  471264 Oct  5 15:32 main2
$

use `--bin` flag to run the specific binary:

$ cargo run --bin main
$ cargo run --bin main2


---


When a package contains binary crate and library crate:

$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'

|____src
| |____bin
| | |____main2.rs
| |____lib.rs
| |____add2.rs
| |____main.rs

$ ls -l target/debug
-rw-r--r--    1 ljh  staff   38448 Oct  5 15:32 libmain.rlib
-rwxr-xr-x    1 ljh  staff  471264 Oct  5 15:32 main
-rwxr-xr-x    1 ljh  staff  471264 Oct  5 15:32 main2
$


---


// static dynamic linking

// $ ldd target/debug/main
// $ otool -L target/debug/main
// $ nm -C libfoo.lib
// $ objdump -t libfoo.lib
// $ readelf -s libfoo.lib

// The Cargo Book, 3.2 The Manifest Format: ./rust/html/cargo/reference/manifest.html ,
// The Cargo Book, 3.2.1 Cargo Targets: ./cargo/reference/cargo-targets.html#library ,

// The Rust Reference, 14 Linkage: ./reference/linkage.html?highlight=creat-type#linkage ,
// The available options are bin, lib, rlib, dylib, cdylib, staticlib, and proc-macro.

# Cargo.toml:

[package]

[lib]
crate-type = ["cdylib"]
bench = false


---


Defining Modules to Control Scope and Privacy ,
https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html ,

The pub mod garden; line tells the compiler to include the code it finds in src/garden.rs ,


---


Separating Modules into Different Files ,
https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html ,

- in this case, the crate root file is src/lib.rs,
but this procedure also works with binary crates
whose crate root file is src/main.rs.

- the compiler knows to look in this file: src/front_of_house.rs,
because it came across the module declaration
in the crate root with the name front_of_house.

// cat src/lib.rs ,
mod front_of_house; // there should be a file: front_of_house.rs ,
pub use crate::front_of_house::hosting;
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

- hosting is a child module of front_of_house, not of the root module.

- module tree ,

// src/front_of_house.rs ,
pub mod hosting;

// src/front_of_house/hosting.rs ,
pub fn add_to_waitlist() {}


---


1. define a module

$ cat foo.rs

pub fn f1() {} // standalone function

mod foo2 {
    pub fn f2() {}
}

2. declare a module

mod foo; // equals to base name of a file
foo::f1();
foo::foo2::f2();

3. declare submodules:
    In any file other than the crate root, you can declare submodules.

// mod foo; // don't use syntax in lib.rs
foo::hello(); // just use name directly

4. module tree:
    should be defined in src/lib.rs.

// https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html ,


---


// print log filename line number

// let name = "abc"
// let num = 123

// dbg!(format_args!("{}, {}", name, num));
// dbg2!("{}, {}", name, num);
macro_rules! dbg2 {
    ($($args:tt)*) => {
        dbg!(format_args!($($args)*))
    };
}

// println2!("{}, {}", name, num);
macro_rules! println2 {
    ($($args:tt)*) => {
        println!("{}:{}: {}", file!(), line!(), format_args!($($args)*));
    };
}

/*
[main/src/main.rs:1:5] format_args!("{}, {}", name, num) = "abc, 123"
[main/src/main.rs:2:5] format_args! ("{}, {}", name, num) = "abc, 123"
main/src/main.rs:19: abc, 123
*/


---


chatGPT:

Understanding Through println! Definition

The definition of println! involves the macro expanding
to use format_args_nl! and _print. Here's the relevant part:

$crate::io::_print($crate::format_args_nl!($($arg)*));

format_args_nl!:
This macro takes the arguments and prepares them for formatting.
When you pass a (a String),
it processes it and ensures the correct type (a &str) is passed to the formatter.

_print:
This function is responsible for the actual printing.
It takes the formatted arguments and writes them to the output stream.
By this point, the value of a has already been coerced into &str by the formatting machinery.

Thus, the println! macro does not directly "care" about the exact type of a
beyond the requirements of the formatting machinery.
The String is automatically coerced to &str because the formatting system
expects a Display implementation for &str.


---


// use it like the println! macro, so both work without taking ownership.
// type_name2!(text)
// type_name2!(&text)

macro_rules! type_name2 {
    ($arg:expr) => {{
        fn type_name2<T: ?Sized>(_: &T) -> &str {
            std::any::type_name::<T>()
        }
        type_name2(&$arg)
    }};
}

fn main() {
    let v = vec![1, 2, 3];
    let a = [1, 2, 3];

    dbg!(format_args!("{}", type_name2!(v)));
    dbg!(format_args!("{}", type_name2!(a)));
    dbg!(format_args!("{}", type_name2!(&v)));
    dbg!(format_args!("{}", type_name2!(&a)));
    dbg!(format_args!("{}", type_name2!(&v[..])));
    dbg!(format_args!("{}", type_name2!(&a[..])));

    dbg!(format_args!("{}", type_name2!(v[..]))); // ?Sized
    dbg!(format_args!("{}", type_name2!(a[..]))); // ?Sized

    let a2 = a;
    let v2 = v;
}

/*
[main/src/main.rs:16:5] format_args!("{}", type_name2!(v)) = "alloc::vec::Vec<i32>"
[main/src/main.rs:17:5] format_args!("{}", type_name2!(a)) = "[i32; 3]"
[main/src/main.rs:18:5] format_args!("{}", type_name2!(&v)) = "&alloc::vec::Vec<i32>"
[main/src/main.rs:19:5] format_args!("{}", type_name2!(&a)) = "&[i32; 3]"
[main/src/main.rs:20:5] format_args!("{}", type_name2!(&v[..])) = "&[i32]"
[main/src/main.rs:21:5] format_args!("{}", type_name2!(&a[..])) = "&[i32]"
[main/src/main.rs:23:5] format_args!("{}", type_name2!(v[..])) = "[i32]"
[main/src/main.rs:24:5] format_args!("{}", type_name2!(a[..])) = "[i32]"
*/


---


// logrotation with log4rs:

$ cat lib.rs

// https://github.com/estk/log4rs/blob/main/examples/log_to_file_with_rolling.rs ,

pub use log::{debug, error, info, trace, warn};
use log::{LevelFilter, SetLoggerError};
use log4rs::{
    append::{
        console::{ConsoleAppender, Target},
        rolling_file::policy::compound::{
            roll::fixed_window::FixedWindowRoller, trigger::size::SizeTrigger, CompoundPolicy,
        },
    },
    config::{Appender, Config, Root},
    encode::pattern::PatternEncoder,
    filter::threshold::ThresholdFilter,
};

pub fn init_logging(dir: &str, name: &str) -> Result<(), SetLoggerError> {
    const TRIGGER_FILE_SIZE: u64 = 1024u64 * 1024 * 1;
    const LOG_FILE_COUNT: u32 = 10;
    let file_path: &str = &format_args!("{dir}/{name}.log");

    // https://docs.rs/log4rs/*/log4rs/append/rolling_file/policy/compound/roll/fixed_window/struct.FixedWindowRollerBuilder.html#method.build ,
    let archive_pattern: &str = &format_args!("{dir}/{name}.{{}}.log");

    // https://docs.rs/log4rs/latest/log4rs/encode/pattern/index.html ,
    let pattern = "{d} {l} {file}:{line} - {m}\n";

    let trigger = SizeTrigger::new(TRIGGER_FILE_SIZE);
    let roller = FixedWindowRoller::builder()
        .build(archive_pattern, LOG_FILE_COUNT)
        .unwrap();
    let policy = CompoundPolicy::new(Box::new(trigger), Box::new(roller));

    // Pattern: https://docs.rs/log4rs/*/log4rs/encode/pattern/index.html ,
    // Logging to log file. (with rolling)
    let logfile = log4rs::append::rolling_file::RollingFileAppender::builder()
        .encoder(Box::new(PatternEncoder::new(pattern)))
        .build(file_path, Box::new(policy))
        .unwrap();

    // Build a stderr logger.
    let stderr = ConsoleAppender::builder()
        .target(Target::Stderr)
        .encoder(Box::new(PatternEncoder::new(pattern)))
        .build();

    let config = Config::builder()
        .appender(
            Appender::builder()
                .filter(Box::new(ThresholdFilter::new(log::LevelFilter::Trace)))
                .build("logfile", Box::new(logfile)),
        )
        .appender(
            Appender::builder()
                .filter(Box::new(ThresholdFilter::new(log::LevelFilter::Trace)))
                .build("stderr", Box::new(stderr)),
        )
        .build(
            Root::builder()
                .appender("logfile")
                .appender("stderr")
                .build(LevelFilter::Trace),
        )
        .unwrap();

    let _handle = log4rs::init_config(config)?;
    Ok(())
}

$


$ cat main.rs

use log2::init_logging;
use log2::{debug, error, info, trace, warn};

fn main() {
    let dir = "./logs";
    let name = "foo";
    init_logging(dir, name);

    // Generate some log messages to trigger rolling
    loop {
        error!("This is error message!");
        warn!("This is warn message!");
        info!("This is info message!");
        debug!("This is debug message!");
        trace!("This is trace message!");
    }
}

$


$ cd /path/to/mymodule  # package directory with Cargo.toml
$ cargo add log4rs log  # it will add dependencies and edit Cargo.toml

// workspace/members: "log2"
// package/dependencies: log2 = {path = "../log2"}

/*

filename pattern:

foo.log
foo.0.log
foo.1.log
foo.2.log

log messages:

2024-09-30T23:09:10.152026+08:00 ERROR hello/src/main.rs:87 - This is error message!
2024-09-30T23:09:10.152077+08:00 WARN hello/src/main.rs:88 - This is warn message!
2024-09-30T23:09:10.152127+08:00 INFO hello/src/main.rs:89 - This is info message!
2024-09-30T23:09:10.152178+08:00 DEBUG hello/src/main.rs:90 - This is debug message!
2024-09-30T23:09:10.152873+08:00 TRACE hello/src/main.rs:91 - This is trace message!

*/


---


const N1: i32 = 5; // const at compile time
let n2 = 5;     // readonly variable at runtime
let mut n3 = 5; // mutable variable

let mut guess = String::new();      // make new instance from heap
io::stdin().read_line(&mut guess)   // the & indicates its a reference

static mut N4: isize = 1; // global variable
unsafe {
    N4 += 1;
    println!("{N4}")
}


---


fn main() {

    /*
    warn:
    value assigned to `age3` is never read
    maybe it is overwritten before being read?
    `#[warn(unused_assignments)]` on by default

    solution:
    use this immediately after the line with the warning:
      let _ = foo;
    */
    let mut age = 12;
    let _ = age;
    age = 13;
    let _ = age;

    //answer 1
    let mut age2 = 12;
    let _ = age2;
    age2 = 13;
    let _ = age2;

    //answer 2
    let mut age3: i32; // or remove initial value
    age3 = 12;
    let _ = age3;
    age3 = 13;
    // let _ = age3;

}


---


fn main() {
    // let mut animal: Box<dyn Animal> = Box::new(Duck{});
    let mut animal: &dyn Animal = &Duck{}; // non Box
    animal.noise();

    // animal = Box::new(Chick{});
    animal = &Chick{}; // non Box
    animal.noise();
}

trait Animal {
    fn noise(&self);
}

struct Duck {}

struct Chick {}

impl Animal for Duck {
    fn noise(&self) {
        println!("{}:{}: {}", file!(), line!(), "ga ga ga");
    }
}

impl Animal for Chick {
    fn noise(&self) {
        println!("{}:{}: {}", file!(), line!(), "ji ji ji");
    }
}


---


$ pwd
/tmp/hello_rust
$
$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'

|____src
| |____lib.rs
| |____main.rs
$
$ cat src/lib.rs

pub mod mymod { // with mod

    pub fn add(left: usize, right: usize) -> usize {
        left + right
    }

} // mod

$
$ cat src/main.rs
// use hello_rust::add; // no mod
use hello_rust::mymod; // with mod

fn main() {
    let a = add(1, 2); // no mod
    let b = mymod::add(1, 2); // with mod
}
$


---


fn main() {
    // https://doc.rust-lang.org/stable/rust-by-example/scope/move/partial_move.html ,
    let p1 = People{name: "tom".to_string(), nickname: "tom".to_string(),};
    // let People{name, ref nickname} = p1;
    // let a = p1.name; //partial move for struct field
    let b = &p1.name;
    println!("{}:{}: {:?} {:?}", file!(), line!(), "p1", p1.nickname);

    // partial move for tuple too
    let a = "tom".to_string();
    let b = "tom".to_string();
    let c = (a, b);
    let d = c.0;
    // println!("{}:{}: {:?}", file!(), line!(), c);

    // but no partial move for vec elements
    let v = vec!["tom".to_string(),"tom".to_string(),"tom".to_string(),];
    // let a = v[0]; //cannot move out of index of `Vec<String>`
    let a = &v[0];
    println!("{}:{}: {:?}", file!(), line!(), v);

}

#[derive(Debug)]
struct People {
    name: String,
    nickname: String,
}


---


{
    // tuple equality and comparision support max 12 elements
    // use nested tuple to work around this problem.
    let a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, (12, 13, 14, 15));
    let b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, (12, 13, 14, 15));
    // let c = a == b; // tuple max elements 12
    // let d = a < b; // tuple max elements 12
    // dbg!(format_args!("{:?}", a)); // tuple max elements 12
}


---


fn main() {
    let s1 = "hello".to_string();
    let s2 = s1;
    let s3 = s1;  // error: use of moved value
    let s4 = &s1;  // error: borrow of moved value
}



---


fn main() {
    // Result

    let result: Result<i32, &str> = Ok(123);
    // let result: Result<i32, &str> = Err("Error message");

    if let Ok(value) = result {
        println!("result: {}", value);
    }
    if let Err(e) = result {
        println!("is_err: {e}");
    }

    if result.is_ok() {
        println!("result: {}", result.unwrap());
    }
    if result.is_err() {
        println!("is_err: {}", result.unwrap_err());
    }

    // Option

    let option: Option<i32> = Some(123);
    // let option: Option<i32> = None;

    if let Some(value) = option {
        println!("option: {}", value);
    }
    if let None = option {
        println!("is_none");
    }

    if option.is_some() {
        println!("option: {}", option.unwrap());
    }
    if option.is_none() {
        println!("is_none");
    }
}


---


// rust-by-example/flow_control/let_else.html, 8.7:

fn main() {
    let text = "123";
    let parse = text.parse::<i32>();
    let Ok(num) = parse.as_ref() else {
        dbg!(format_args!("{}", parse.as_ref().unwrap_err()));
        return;
    };
    dbg!(format_args!("{}, {}", text, num));

    let text = "abc";
    let parse = text.parse::<i32>();
    let Ok(num) = parse.as_ref() else {
        dbg!(format_args!("{}", parse.as_ref().unwrap_err()));
        return;
    };

    dbg!(format_args!("{}, {}", text, num));
}

/*
[main/src/main.rs:17:5] format_args!("{}, {}", text, num) = "123, 123"
[main/src/main.rs:22:9] format_args!("{}", parse.as_ref().unwrap_err()) = "invalid digit found in string"
 */


---


fn main() {
    // &str string slice is immutable by default.
    // to_lowercase() returns a temporary object
    // which goes out of scope before the temporary is assigned.

    // 1. error
    // let mut a = "ABcd";
    // a = a.to_lowercase().as_str(); // error.

    // 2. ok
    let mut a = String::from("ABcd");
    a = a.to_lowercase();
    println!("{}", a);

    // 3. ok
    let a = "ABcd".to_lowercase();
    let b = &a; // ok.
    let b = a.as_str(); // ok.
    println!("{b}");

}


---


// do not do random access index or slicing in string slice directly.
// convert string slice to Vec.

fn main() {
    // let hello = "Здравствуйте";
    // let s = &hello[0..1];

    // error: byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
    // println!("{s}");

    let v: Vec<char> = "Здравствуйте".chars().collect();
    let s = &v[0..1]; // ok
    let s: String = s.iter().collect();
    println!("{s}");
}


//---


// do not search or find in string slice directly.
// convert string slice to Vec.

fn main() {

    // https://doc.rust-lang.org/book/ch08-02-strings.html ,
    // If we were to try to slice only part of a character bytes with something
    // like &hello[0..1], Rust would panic at runtime in the same way as if an
    // invalid index were accessed in a vector:

    // do not search in string slice,

    // let name = "Здравствуйте"; // "abcdef123";
    // let needle = 'e';
    // let first: i32 = 1;
    // let last: i32 = 2; // name.len() as i32;

    // let pos = &name[first as usize..last as usize].find(needle); // error
    // let pos = pos.unwrap_or(usize::MAX) as i32;
    // println!("ret: {}, found: {}, index: {}", pos, pos != -1, pos + first);
}


// search or find in Vec.

fn main() {
    let haystack = vec![1, 2, 3, 2, 4, 2, 5];
    let needle = 2;

    let mut first = 0; // 0; // 2;
    let last = 5; // haystack.len(); // 5;

    while let Some(i) = haystack[first..last].iter().position(|&x| x == needle) {
        let index = first + i;
        println!("index: {}", index);
        first = index + 1;
    }
}


fn main() {
    let haystack = vec![1, 2, 3, 2, 3, 4, 5];
    let needle = 2;

    let mut first = 0; // 0; // 2;
    let last = 5; // haystack.len(); // 5;

    for (index, &value) in haystack[first..last].iter().enumerate() {
        if value == needle {
            println!("Found {} at index: {}", needle, first + index);
        }
    }
}


fn main(){
    let haystack = vec![1, 2, 3, 2, 4, 2, 5];
    let needle = 2;

    let mut first = 0; // 0; // 2;
    let last = 5; // haystack.len(); // 5;

    for i in first..last {
        if haystack[i] == needle {
            println!("Found {} at index: {}", needle, i);
        }
    }
}


fn main() {
    let s = "BaBBaBBaB";
    let haystack: Vec<char> = s.chars().collect();
    let needle = 'a';

    let mut first = 0; // 0; // 2;
    let last = 5; // haystack.len(); // 5;

    while let Some(i) = haystack[first..last].iter().position(|&x| x == needle) {
        let index = first + i;
        println!("index: {}", index);
        first = index + 1;
    }
}


//---


// find or search for multiple occurrences of substring in range in a larger string
// and return the position index.
// returns the index of the first occurrence in each iteration in loop.

fn main() {
    let haystack = "The quick brown fox jumps over the lazy dog. The fox is clever. fox!!!";
    let needle = "fox"; // "f";
    let haystack = haystack.to_lowercase();
    let needle = needle.to_lowercase();

    // Find all occurrences of the substring
    // in half open range of (first..last]
    let mut first = 0;
    let last = 56; // haystack.len(); // 56;

    while let Some(i) = haystack[first..last].find(&needle) {
        let index = first + i;
        println!("index: {}", index);
        first = index + 1;
    }
}


---


// find search multiple occurrences of sub sequence in range of a larger sequence or vector
// and return the position index.

fn main() {
    let haystack = vec![1, 2, 3, 4, 2, 3, 4, 5, 2, 3];
    let needle = vec![2, 3];

    let mut first = 0;
    let last = 6; // haystack.len(); // 6;

    for (i, window) in haystack[first..last].windows(needle.len()).enumerate() {
        if window == needle {
            let index = i + first;
            println!("index: {}", index);
        }
    }
    println!("---------");

    // or
    while let Some(i) = haystack[first..last]
        .windows(needle.len())
        .position(|window| window == needle)
    {
        let index = i + first;
        println!("index: {}", index);
        first = index + 1;
    }
}


---


// quick sort, binary search, find,
// rust partition_point, c++ lower_bound, upper_bound, equal_range,

fn main() {
    let mut haystack = vec![
        Foo { name: String::from("apple"), num: 1, },
        Foo { name: String::from("apple"), num: 1, },
        Foo { name: String::from("banana"), num: 2, },
        Foo { name: String::from("banana"), num: 2, },
        Foo { name: String::from("orange"), num: 3, },
    ];
    let needle = Foo {
        name: String::from("banana"),
        num: 2,
    }; // "aaabanana", "banana", "zzzbanana"

    haystack.sort();

    let lower = haystack.partition_point(|x| x < &needle);
    let upper = haystack.partition_point(|x| x <= &needle);

    if lower == upper {
        println!("not found");
    }
    for i in lower..upper {
        println!("{}: {:?}, {:?}", line!(), i, haystack[i]);
    }
}

#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
struct Foo {
    name: String,
    num: i32,
}


---


Equality operators == , != ;
relationship ordering operators < , > ;

- `Eq` and `Ord` cannot be with types may have non-equivalent or non-comparable values like `NaN` or infinity;
    attempting to implement these traits for such types will result in a compile-time error.

- `PartialEq` returns `false` if any operand is non-equivalent, such as `NaN` (e.g., `NaN == NaN` is `false`).
- `PartialOrd` returns `None` if any operand is non-comparable, such as `NaN` (e.g., `NaN < 5.0` returns `None`).


---


fn main() {
    // change character in string by replace_range
    let mut s = String::from("hello");
    println!("{:?}", s); // "hello"
    s.replace_range(0..1, "H");
    println!("{:?}", s); // "Hello"

    // convert string to vec of character
    let s = String::from("hello");
    let mut v: Vec<char> = s.chars().collect();
    v[0] = 'H';
    println!("{:?}", v); // ['h', 'e', 'l', 'l', 'o']

    // convert vec of character to string
    let s: String = v.iter().collect();
    println!("{}", s); // "hello"
}


---


fn main() {
    let arr = vec![1, 2, 3, 4];
    let vec: Vec<_> = arr.iter().map(|v| v.to_string()).collect();
    dbg!(format_args!("{:?}", vec));
}


fn main() {
    let arr = vec![1, 2, 3];
    let vec: Vec<String> = arr
        .iter()
        .flat_map(|&v| std::iter::once(v.to_string()))
        .collect();

    dbg!(format_args!("{:?}", vec));
}


// The purpose of flattening in flat_map is to handle cases where each element of
// an iterator maps to a collection (like another iterator, vector, or string),
// and you want to merge all those collections into a single iterator.
// Essentially, flat_map combines mapping and flattening into one operation.
//
// It can make nested data <Vec<Vec<char>> into a flat data <Vec<char>> .

fn main() {
    let nested_vec: Vec<Vec<char>> = vec![vec!['a', 'b'], vec!['c', 'd'], vec!['e']];
    dbg!(format_args!(
        "{:?}, {:?}",
        nested_vec,
        type_name2!(nested_vec)
    ));
    let flat_vec: Vec<char> = nested_vec
        .into_iter()
        .flat_map(|inner_vec| inner_vec)
        .collect();
    dbg!(format_args!("{:?}, {:?}", flat_vec, type_name2!(flat_vec)));
}


---


https://doc.rust-lang.org/book/ch17-01-what-is-oo.html ,

use trait for polymorphism or interface ,

Polymorphism,

To many people, polymorphism is synonymous with inheritance.
But its actually a more general concept that refers to code that can
work with data of multiple types.
For inheritance, those types are generally subclasses.

Rust instead uses generics to abstract over different possible types
and trait bounds to impose constraints on what those types must provide.
This is sometimes called bounded parametric polymorphism.


---


https://doc.rust-lang.org/rust-by-example/generics/bounds.html ,

generics use trait to constrain type parameter,

Bounds,

When working with generics, the type parameters often must
use traits as bounds to stipulate what functionality a type implements.

For example, the following example uses the trait Display to print and
so it requires T to be bound by Display; that is, T must implement Display.

// Define a function `printer` that takes a generic type `T` which
// must implement trait `Display`.
fn printer<T: Display>(t: T) {
    println!("{}", t);
}


// https://docs.modular.com/mojo/manual/traits ,
// Generic structs with traits,
// You can also use traits when defining a generic container.


---


https://doc.rust-lang.org/rust-by-example/generics/gen_trait.html ,

trait can be generic itself ,

Traits,

Of course traits can also be generic.
Here we define one which reimplements the Drop trait as a generic method
to drop itself and an input.


---


https://doc.rust-lang.org/rust-by-example/scope/borrow.html ,

move is value semantics,
borrow is reference semantics,

Borrowing,

Most of the time, we'd like to access data without taking ownership over it.
To accomplish this, Rust uses a borrowing mechanism.
Instead of passing objects by value (T), objects can be passed by reference (&T).


---


https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html ,

move is a shallow copy, it invalidates the original moved object ,

If you have heard the terms shallow copy and deep copy while working with other languages,
the concept of copying the pointer, length, and capacity without copying the data probably
sounds like making a shallow copy.
But because Rust also invalidates the first variable,
instead of being called a shallow copy, it is known as a move.


---


// temporary value is freed at the end of this statement
{
    let a = String::from("abc").as_str();   // err
    dbg!(a);
}

// consider using a `let` binding to create a longer lived value
{
    let s1 = String::from("abc");
    let a = s1.as_str();                    // ok
    dbg!(a);
}


---


The Rust Programming Language, 10.3:

We want the signature to express the following constraint: the returned
reference will be valid as long as both the parameters are valid. This is the
relationship between lifetimes of the parameters and the return value.

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

The function signature now tells Rust that for some lifetime 'a, the function
takes two parameters, both of which are string slices that live at least as long
as lifetime 'a.
The function signature also tells Rust that the string slice returned from the
function will live at least as long as lifetime 'a. In practice, it means that
the lifetime of the reference returned by the longest function is the same as
the smaller of the lifetimes of the values referred to by the function
arguments.
These relationships are what we want Rust to use when analyzing this code.

Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints.

The lifetime annotations become part of the contract of the function, much like
the types in the signature.
Having function signatures contain the lifetime contract means the analysis the
Rust compiler does can be simpler.


fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}

for result to be valid for the println! statement, string2 would need to be
valid until the end of the outer scope.
Rust knows this because we annotated the lifetimes of the function parameters
and return values using the same lifetime parameter 'a.

We’ve told Rust that the lifetime of the reference returned by the longest
function is the same as the smaller of the lifetimes of the references passed
in.
Therefore, the borrow checker disallows the code as possibly having an invalid
reference.

Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions.
Once they’re connected, Rust has enough information to allow memory-safe
operations and disallow operations that would create dangling pointers or
otherwise violate memory safety.


---


fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// rust-by-example/scope/lifetime/explicit.html, 15.4 Explicit annotation,

fn first<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    x
}

fn last<'a, 'b>(x: &'a str, y: &'b str) -> &'b str {
    y
}

fn main() {
    {
        let string1 = String::from("abcd");
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
        dbg!(format_args!("The longest string is {result}"));
    }

    {
        let string1 = String::from("long string is long");
        {
            let string2 = String::from("xyz");
            let result = longest(string1.as_str(), string2.as_str());
            dbg!(format_args!("The longest string is {result}"));
        }
    }

    {
        let string1 = String::from("long string is long");
        let result;
        {
            let string2 = String::from("xyz");
            // result = longest(string1.as_str(), string2.as_str()); // err
            result = first(string1.as_str(), string2.as_str()); // ok
        }
        dbg!(format_args!("The longest string is {result}"));
    }

    {
        let string2 = String::from("xyz");
        let result;
        {
            let string1 = String::from("long string is long");
            // result = longest(string1.as_str(), string2.as_str()); // err
            result = last(string1.as_str(), string2.as_str()); // ok
        }
        dbg!(format_args!("The longest string is {result}"));
    }
}


---


The Rust Programming Language, 13.1:

Capturing References or Moving Ownership

Closures can capture values from their environment in three ways,
which directly map to the three ways a function can take a parameter:
borrowing immutably, borrowing mutably, and taking ownership.


---


4.2:

Mutable references have one big restriction:
if you have a mutable reference to a value,
you can have no other references to that value.

The benefit of having this restriction is that Rust can prevent data races
at compile time.

Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used.

fn f1() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3); // error
}

fn f2() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}", r3); // ok
}

The scopes of the immutable references r1 and r2 end after the println! where
they are last used, which is before the mutable reference r3 is created.

At any given time,
you can have either one mutable reference or any number of immutable references.


---


index is checked on array, vector, HashMap:

3.2, Array:

check that the index of array, and panic on invalid index.
index out of bounds: the len is 4 but the index is 10.

8.1, Vector:


8.3, HashMap:

Hash maps are useful when you want to look up data not by using an index,
as you can with vectors, but by using a key that can be of any type.


---


// unit tests, integration tests

$ pwd
/Users/ljh/Documents/rust_work/main
$
$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'

.
|____Cargo.toml
|____tests
| |____integration_test2.rs
|____src
| |____tests2.rs
| |____lib.rs
| |____add2.rs
| |____main.rs
$
$ ls
Cargo.toml      src             tests
$
$ ls src
add2.rs         lib.rs          main.rs         tests2.rs
$
$ ls tests
integration_test2.rs
$

$ cat Cargo.toml
[package]
name = "main"
version = "0.1.0"
edition = "2021"

[dependencies]
# log2 = {path = "../log2"}
$

$ cat src/add2.rs
pub fn add2(a: i32, b: i32) -> i32 {
    dbg!(format_args!("{}", a + b));
    a + b
}
$

$ cat src/lib.rs
pub mod add2;

#[cfg(test)]
pub mod tests2;

pub fn add(a: i32, b: i32) -> i32 {
    dbg!(format_args!("{}", a + b));
    a + b
}
$

$ cat src/main.rs

// src/main.rs is binary crate. src/lib.rs is library crate.
// they are different crates, so, in src/main.rs,
// can not do use keywords: crate, super: ` use crate::foo `.
// instead, use through package name: ` use pack_name::foo `

use main::add;
use main::add2::add2;

fn main() {
    let sum = add(1, 2);
    dbg!(format_args!("{}", sum));
    let sum = add2(1, 2);
    dbg!(format_args!("{}", sum));
}
$

$ cat src/tests2.rs
use super::add2::*;
use super::*;

#[test]
fn ut_add() {
    assert_eq!(add(1, 2), 3);
}

#[test]
fn ut_add2() {
    assert_eq!(add2(1, 2), -3); // false test
}
$

$ cat tests/integration_test2.rs
use main::add;
use main::add2::add2;

#[test]
fn it_add() {
    assert_eq!(add(1, 2), 3);
}

#[test]
fn it_add2() {
    assert_eq!(add2(1, 2), -3); // false test
}
$

$ cargo test
test tests2::ut_add ... ok
test tests2::ut_add2 ... FAILED
$

$ cargo test --test integration_test2
test it_add ... ok
test it_add2 ... FAILED
$


---


// Crate std, The Rust Standard Library

// std/ops/index.html,

the assignment operator (=) has no backing trait,
there is no way of overloading its semantics.


Many of the operators take their operands by value.
In non-generic contexts involving built-in types, this is usually not a problem.
However, using these operators in generic code,
requires some attention if values have to be reused as opposed to letting the
operators consume them. One option is to occasionally use clone.

Another option is to rely on the types involved providing additional operator
implementations for references.
For example, for a user-defined type T which is supposed to support addition,
it is probably a good idea to have both T and &T implement
the traits Add<T> and Add<&T> so that generic code can be written
without unnecessary cloning.


---


Learn Rust With Entirely Too Many Linked Lists ,
Double Singly-Linked List ,
or doubly-linked list ,

https://rust-unofficial.github.io/too-many-lists/third-arc.html ,

Interior mutability types violate this: they let you mutate through a shared
reference. There are two major classes of interior mutability: cells, which
only work in a single-threaded context; and locks, which work in a
multi-threaded context. For obvious reasons, cells are cheaper when you can use
them. There's also atomics, which are primitives that act like a lock.

So what does all of this have to do with Rc and Arc? Well, they both use
interior mutability for their reference count. Worse, this reference count is
shared between every instance! Rc just uses a cell, which means it's not thread
safe. Arc uses an atomic, which means it is thread safe. Of course, you can't
magically make a type thread safe by putting it in Arc. Arc can only derive
thread-safety like any other type.


https://rust-unofficial.github.io/too-many-lists/fourth-building.html ,

Shareable mutable containers.

Values of the Cell<T> and RefCell<T> types may be mutated through shared
references (i.e. the common &T type), whereas most Rust types can only be
mutated through unique (&mut T) references. We say that Cell<T> and RefCell<T>
provide 'interior mutability', in contrast with typical Rust types that exhibit
'inherited mutability'.

Cell types come in two flavors: Cell<T> and RefCell<T>. Cell<T> provides get
and set methods that change the interior value with a single method call.
Cell<T> though is only compatible with types that implement Copy. For other
types, one must use the RefCell<T> type, acquiring a write lock before mutating.


---


https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html ,

Mutable references have one big restriction: if you have a mutable reference to
a value, you can have no other references to that value. This code that
attempts to create two mutable references to s will fail:

```
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
```


https://doc.rust-lang.org/stable/book/ch15-05-interior-mutability.html ,
RefCell<T> and the Interior Mutability Pattern ,

use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let s = Rc::new(RefCell::new(String::from("hello")));

    let s1 = Rc::clone(&s); // increases the reference count
    let s2 = Rc::clone(&s); // increases the reference count

    // These must be in separate scopes or explicitly dropped
    {
        let mut r1 = s1.borrow_mut();
        r1.push_str(" world");
    } // r1 goes out of scope here

    {
        let mut r2 = s2.borrow_mut();
        r2.push_str(" again!");
    }

    println!("{}", s.borrow()); // prints "hello world again!"
}


---






























---


  </textarea>

</body>

</html>
